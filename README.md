1. Аналіз предметної області
1.1. Постановка задачі
Предметною областю є діяльність компанії з прокату автомобілів. Специфіка бізнесу передбачає динамічну зміну стану об'єктів (автомобілі постійно беруться в оренду та повертаються), а також необхідність швидкого доступу до інформації про конкретний транспортний засіб у великій базі даних.
Ключовою проблемою при збільшенні автопарку стає швидкість обробки запитів. Використання найпростіших лінійних структур даних призводить до затримок, оскільки оператор змушений чекати результатів пошуку або оновлення бази. Метою роботи є розробка програмного забезпечення, що використовує бінарне дерево пошуку для оптимізації процесів, та порівняння його ефективності з дінамічним масивом чи хеш-функцією.
1.2. Вимоги до програмного забезпечення
•	Управління базою даних: Завантаження списку автомобілів із зовнішнього файлу  та збереження оновлених даних при виході.
•	Графічний інтерфейс: Програма повинна мати інтуїтивно зрозумілий віконний інтерфейс (кнопки, таблиці, форми вводу), а не консольний.
•	Бізнес-логіка оренди: Реалізація функцій «Видати авто» (зміна статусу на зайнятий) та «Прийняти авто» (зміна статусу на вільний).
•	Пошук: Швидкий пошук автомобіля за унікальним ID.
•	Звітність: Виведення повного списку автомобілів, відсортованого за ID.
•	Експериментальна частина: Проведення замірів продуктивності (кількість ітерацій/час) для операцій пошуку в дереві та в масиві.
•	Ефективність пам'яті: відсутність витоків пам'яті при видаленні вузлів дерева.
1.3. Аналіз існуючих алгоритмів та структур даних
Для реалізації системи було порівняно три підходи:
1.	Динамічний масив
•	Пошук: Вимагає повного перебору елементів. Це неефективно для великих баз даних.
•	Модифікація: Вставка елемента в середину або видалення вимагає зсуву всіх наступних елементів у пам'яті, що є ресурсоємною операцією.
•	Висновок: Використовується в роботі лише як базовий рівень для демонстрації неефективності лінійного підходу.
2.	Бінарне дерево пошуку:
•	Пошук: Забезпечує логарифмічну складність у середньому випадку, відсікаючи половину масиву даних на кожному кроці.
•	Модифікація: Додавання та видалення записів відбувається шляхом зміни вказівників, без необхідності фізичного переміщення великих блоків даних у пам'яті.
•	Висновок: Обрано як основну структуру даних для системи оренди.
3.	Хеш-таблиця:
•	Принцип: Використання функції перетворення ключа в індекс масиву.
•	Пошук: миттєвий доступ (у найкращому випадку).
•	Недолік: Дані зберігаються хаотично (невпорядковано), можливі колізії.
•	Висновок: Використовується для демонстрації максимально швидкого пошуку конкретного авто.

2. Проєктування програмного забезпечення
2.1. Засоби розробки
•	Мова програмування: C++ (для демонстрації роботи з вказівниками та пам'яттю).
•	Середовище: Visual Studio / VS Code.
•	Бібліотека GUI: Windows Forms (C++/CLI)
•	Формат збереження даних: Текстові файли .txt або .csv для персистентності даних.
2.2. Структура роботи з даними
Основним об'єктом системи є сутність Car.
Атрибути об'єкта Car:
1.	ID  - унікальний ідентифікатор.
2.	Brand - марка.
3.	Model - модель.
4.	Year - рік випуску.
5.	Price - ціна за добу.
6.	IsRented  - статус (0 - вільно, 1 - в оренді).

Для організації даних розроблено класи-обгортки:
1.	CarVector - обгортка над стандартним вектором.
2.	CarTree - власна реалізація бінарного дерева пошуку з вузлами Node.
3.	CarHashTable - реалізація хеш-таблиці з вирішенням колізій методом ланцюжків
2.3. Структура програми та алгоритмічні рішення
А. Модуль хешування
Оскільки ID автомобіля є цілим числом, обрано метод ділення.
•	Хеш-функція
•	Вирішення колізій: Використовується метод ланцюжків. Хеш-таблиця являє собою масив вказівників на зв'язні списки (std::list або власний LinkedList). Якщо два ID дають однаковий хеш, новий запис додається в кінець списку відповідної комірки.
Б. Модуль дерева
Стандартна реалізація:
•	Insert: Рекурсивний спуск і додавання листа.
•	InOrder: Рекурсивний обхід (Left -> Root -> Right) для виведення відсортованого списку всіх машин.
В. Порівняльний експеримент
Програма виконує пошук автомобіля за ID (наприклад, ID = 9999) у трьох структурах:
1.	Vector: Проходить циклом for.
2.	Tree: Спускається від кореня.
3.	Hash Table: Обчислює хеш + проходить короткий список колізій (~1-2 операції).
Результатом є таблиця, що наочно демонструє перевагу хеш-таблиці у швидкості пошуку та перевагу дерева у зручності сортування.
Г. Рівень інтерфейсу:
Головне вікно, що містить:
o	Відображення списку автомобілів.
o	Панель керування (Кнопки "Додати", "Видалити", "Пошук", "Тест швидкості").
o	Поля вводу для параметрів авто.

